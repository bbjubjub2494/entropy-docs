"use strict";(self.webpackChunkentropy_core=self.webpackChunkentropy_core||[]).push([[650],{6752:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>c,toc:()=>a});var s=t(4848),i=t(8453);const o={},r="Signing",c={id:"Sign",title:"Signing",description:"The signing process can only take place when a user is already registered on Entropy. The Process involves",source:"@site/docs/08-Sign.md",sourceDirName:".",slug:"/Sign",permalink:"/entropy-docs/Sign",draft:!1,unlisted:!1,editUrl:"https://github.com/entropyxyz/entropy-docs/tree/master/docs/08-Sign.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"DocsSidebar",previous:{title:"Upload Program",permalink:"/entropy-docs/UploadPrograms"},next:{title:"Node Encryption and Authentication",permalink:"/entropy-docs/NodeEncryptionAndAuthentication"}},h={},a=[{value:"Signing process",id:"signing-process",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"signing",children:"Signing"}),"\n",(0,s.jsx)(n.p,{children:"The signing process can only take place when a user is already registered on Entropy. The Process involves\nhaving the user and a committee of validators collectively perform the signing."}),"\n",(0,s.jsx)(n.p,{children:"The committee requires one Validator from each signing group as well as the user. The current version of the program will be executed here to determine whether or not to proceed with the signing protocol."}),"\n",(0,s.jsxs)(n.p,{children:["For details on how signatures are actually created, see ",(0,s.jsx)(n.a,{href:"ThresholdSignatureScheme",children:"Threshold Signature Scheme"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"signing-process",children:"Signing process"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Signing Flow New",src:t(942).A+"",width:"1424",height:"698"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The user computes the hash of the message they wish to sign, and selects a signing committee by deterministically selecting a member of each signing group based on this hash. They can get the details of the signing groups as they were published on chain when the user ",(0,s.jsx)(n.a,{href:"Register",children:"registered"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The user contacts all threshold servers in the signing committee and makes a POST to ",(0,s.jsx)(n.code,{children:"/user/sign_tx"})," with the message to be signed (encrypted for that node)."]}),"\n",(0,s.jsx)(n.li,{children:"On receiving a message, each node checks that it is a member of the signing committee for that message using the hash."}),"\n",(0,s.jsx)(n.li,{children:"The Threshold server retrieves the latest version of the associated program from the entropy chain, and executes it with the message to be signed as input. Only on getting successful program output do they continue to the next step."}),"\n",(0,s.jsxs)(n.li,{children:["The Threshold server sets up websocket connections to or from the rest of the committee to use for threshold signing protocol messages. They decide whether to make an outgoing connection, or accept an incoming one by comparing account IDs. These connections are secured using the ",(0,s.jsx)(n.a,{href:"https://noiseprotocol.org/noise.html",children:"noise protocol"}),". Signing protocol messages can be either 'broadcast' to all of the committee or 'p2p' to a specific member."]}),"\n",(0,s.jsx)(n.li,{children:"Once all members of the signing committee have subscribed, nodes participate in the signing protocol to produce a signature, using the key-shares retrieved from their key-value store."}),"\n",(0,s.jsx)(n.li,{children:"If the signing process fails, nodes broadcast who the malicious/faulty signer was, which is included in the next block. Following that, the next block contains details of a new signing committee. The misbehaving signer will be 'slashed' (not yet implemented)."}),"\n",(0,s.jsxs)(n.li,{children:["If the process is successful, the signature is returned to the user. Currently this requires the user to repeatedly poll POST ",(0,s.jsx)(n.code,{children:"signer/signature"})," with the signature hash, until it successfully retrieves a signature."]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},942:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/signing-new-d77303756536e577c0b29050e859c3a0.svg"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkentropy_core=self.webpackChunkentropy_core||[]).push([[518],{334:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var n=t(4848),o=t(8453);const r={},i="Access Modes",a={id:"AccessModes",title:"Access Modes",description:"Access Modes&ensp;&ensp;",source:"@site/docs/14-AccessModes.md",sourceDirName:".",slug:"/AccessModes",permalink:"/entropy-docs/AccessModes",draft:!1,unlisted:!1,editUrl:"https://github.com/entropyxyz/entropy-docs/tree/master/docs/14-AccessModes.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{},sidebar:"DocsSidebar",previous:{title:"Slashing",permalink:"/entropy-docs/Slashing"},next:{title:"Signing Group Selection",permalink:"/entropy-docs/SigningGroupSelection"}},c={},d=[];function u(e){const s={h1:"h1",img:"img",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"access-modes",children:"Access Modes"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.img,{alt:"Access Modes",src:t(4399).A+"#gh-dark-mode-only"}),"\u2002\u2002\n",(0,n.jsx)(s.img,{alt:"Access Modes",src:t(6029).A+"#gh-light-mode-only"}),"\u2002\u2002"]}),"\n",(0,n.jsx)(s.p,{children:"Entropy accounts can have two distinct access modes."}),"\n",(0,n.jsx)(s.p,{children:"With 'public' access mode anyone can submit a request to sign a message. However, the account may be configured with a program which restricts who can sign messages, or has rules about what kinds of messages different users may sign. Data, such as a signature from the user, may be passed in as auxiliary data to the program. As an example, an organisation whose members change over time would use could use public access with signing rules defined in a program, and the program could be updated whenever the status of group members changes. It is important to note that adding these constrains to an account is available in every access mode."}),"\n",(0,n.jsx)(s.p,{children:"With 'Private' access mode, the user themselves holds a keyshare and participates in the distributed key generation and signing protocols. This is the most secure, as it is impossible for the TSS servers to collude against the user. But it requires that the user safeguards their keyshare, and it requires more complicated UX."})]})}function p(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},4399:(e,s,t)=>{t.d(s,{A:()=>n});const n=t.p+"assets/images/public-private-permissioned-dark-a66f66ffabb3af78d4ab09739613ee96.svg"},6029:(e,s,t)=>{t.d(s,{A:()=>n});const n=t.p+"assets/images/public-private-permissioned-light-17e92bce7b9366b72cf65254219292e7.svg"},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>a});var n=t(6540);const o={},r=n.createContext(o);function i(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);